#A1
import pandas as pd
import numpy as np
file_path = r"C:\Users\vvmad\Downloads\5th\ML\Lab Session Data.xlsx"
buying_data = pd.read_excel(file_path, sheet_name = 'Purchase data')
matA = buying_data[['Candies (#)', 'Mangoes (Kg)', 'Milk Packets (#)']].dropna().values
matC = buying_data['Payment (Rs)'].dropna().values
dim = matA.shape[1]
n_vec = matA.shape[0]
rank = np.linalg.matrix_rank(matA)
A_pseudo_inv = np.linalg.pinv(matA)
matX = A_pseudo_inv @ matC

print("Dimensionality = : ",dim)
print("No of vectors = ",n_vec)
print("Rank of matA: ",rank)
print("Cost of products: :")
print(" - Candies: Rs: {:.2f}".format(matX[0]))
print(" - Mangoes: Rs: {:.2f}".format(matX[1]))
print(" - Milk Packets: Rs: {:.2f}".format(matX[2]))



#A2
#Same as A1



#A3
buying_data['status'] = buying_data['Payment (Rs)'].apply(lambda x: "RICH" if x > 200 else "POOR")
print(buying_data[['Payment (Rs)', 'status']].head())



#A4
import pandas as pd
import numpy as np
import statistics
import matplotlib.pyplot as plt

file_path = r"C:\Users\vvmad\Downloads\5th\ML\Lab Session Data.xlsx"
buying_data = pd.read_excel(file_path, sheet_name = 'IRCTC Stock Price')

data_of_price = buying_data.iloc[:, 3]
mean = statistics.mean(data_of_price)
variance = statistics.variance(data_of_price)
print("Mean = ",mean)
print("Variance = ",variance)

buying_data['Date'] = pd.to_datetime(buying_data['Date'])
wednesday = buying_data[buying_data['Date'].dt.day_name() == 'Wednesday']
mean_wed = statistics.mean(wednesday['Price'])
print(f"Wednesday mean: {mean_wed:.2f}")
print(f"Wednesday Comparison : {mean_wed - mean:.2f}")

apr_data = buying_data[buying_data['Date'].dt.month == 4]
mean_apr = statistics.mean(apr_data['Price'])
print(f"April data: {mean_apr: .2f}")
print(f"April comparison : {mean_apr - mean:.2f}")

chg = buying_data.iloc[:, 8]
loss_prob = np.mean(chg < 0)
print(f"Probability of Loss: {loss_prob:.2f}")

wed_prof = wednesday[chg < 0].shape[0]
total_wed = wednesday.shape[0]
prob_wed_prof = 1-(wed_prof/total_wed)
print(f"Probability of Making a Profit on Wednesday: {prob_wed_prof:.2f}")

prof_if_wed = prob_wed_prof
print(f"Profit if wednesday: {prof_if_wed}")

buying_data['Day of Week'] = buying_data['Date'].dt.day_name()
plt.figure(figsize=(10, 6))
plt.scatter(buying_data['Day of Week'], buying_data['Chg%'])
plt.title('Scatter Plot of chg Against Day of the Week')
plt.xlabel('Day of the Week')
plt.ylabel('Chg%')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()



#A5
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder, OneHotEncoder

file_path = r"C:\Users\vvmad\Downloads\5th\ML\Lab Session Data.xlsx"
thyroid_data = pd.read_excel(file_path, sheet_name = 'thyroid0387_UCI')

thyroid_data.head()

type_of_attribute = thyroid_data.dtypes
print(type_of_attribute)

td_encoded = pd.get_dummies(thyroid_data, drop_first = True)
td_encoded.head()

numeric_summary = thyroid_data.describe()
print(numeric_summary)

missing_values = thyroid_data.isnull().sum()
print(missing_values)

numeric_columns = thyroid_data.select_dtypes(include=['float64','int64']).columns
plt.figure(figsize=(10,8))
sns.boxplot(data=thyroid_data[numeric_columns])
plt.title('Boxplot:')
plt.show()

mean = thyroid_data[numeric_columns].mean()
std_vals = thyroid_data[numeric_columns].std()

print("Mean: ",mean)
print("Std values: ",std_vals)



#A6
categorical_columns = thyroid_data.select_dtypes(include=['object']).columns

for col in numeric_columns:
    if(thyroid_data[col] - thyroid_data[col].mean()).abs().max() <=3 * thyroid_data[col].std():
        thyroid_data[col].fillna(thyroid_data[col].mean(), inplace = True)
    else:
        thyroid_data[col].fillna(thyroid_data[col].median(), inplace = True)

for col in categorical_columns:
    thyroid_data[col].fillna(thyroid_data[col].mode()[0], inplace = True)

missing_values = thyroid_data.isnull().sum()

thyroid_data.head(), missing_values



#A7
print(thyroid_data[numeric_columns].describe())

scaler = MinMaxScaler()
thyroid_data_normalized = thyroid_data.copy()
thyroid_data_normalized[numeric_columns] = scaler.fit_transform(thyroid_data[numeric_columns])

print(thyroid_data_normalized.head())

scaler_standard = StandardScaler()
thyroid_data_standardized = thyroid_data.copy()
thyroid_data_standardized[numeric_columns] = scaler_standard.fit_transform(thyroid_data[numeric_columns])

print(thyroid_data_standardized.head())



#A8
thyroid_data_withoutnan = thyroid_data[binary_cols].dropna()
binary_cols = ['FTI', 'T3', 'TSH']
vec1 = thyroid_data_withoutnan.iloc[0].values
vec2 = thyroid_data_withoutnan.iloc[1].values

f00 = np.sum((vec1 == 0)&(vec2 == 0))
f01 = np.sum((vec1 == 0)&(vec2 == 1))
f10 = np.sum((vec1 == 1)&(vec2 == 0))
f11 = np.sum((vec1 == 1)&(vec2 == 1))

JC = f11/(f01+f10+f11)
SMC = (f11+f00)/(f00+f01+f10+f11)

print("JC is: {:.4f}".format(JC))
print("SMC is: {:.4f}".format(SMC))



#A9

num_data = thyroid_data.select_dtypes(include=[np.number])
vec1_full = thyroid_data.loc[0].values
vec2_full = thyroid_data.loc[1].values

if len(numeric_data) >= 2:
    vec1_full = num_data.iloc[0].values
    vec2_full = num_data.iloc[1].values

    print("Vector 1:", vec1_full)
    print("Vector 2:", vec2_full)

    cosine_similarity = 1 - cosine(vec1_full, vec2_full)
    print("Cosine Similarity: {:.4f}".format(cosine_similarity))
else:
    print("Cannot find cosine sim")



#A10

data_set = thyroid_data.iloc[:20]

for c in data_set.columns:
    if data_set[c].dtype == 'object':
        le = LabelEncoder()
        data_set[c] = le.fit_transform(data_set[c].astype(str))
        
data_set2 = data_set.values

jc_sim = 1-pairwise_distances(data_set2, metric = 'jaccard')
smc_sim = 1-pairwise_distances(data_set2, metric=lambda u, v: np.sum(u==v) / len(u))
cosine_sim = 1-pairwise_distances(data_set2, metric = 'cosine')

plt.figure(figsize=(10,8))
sns.heatmap(jc_sim, annot = True, cmap='coolwarm')
plt.title('Jaccard Similarity Heatmap')
plt.show()

plt.figure(figsize=(10,8))
sns.heatmap(smc_sim, annot = True, cmap='coolwarm')
plt.title('Simple Matching Similarity Heatmap')
plt.show()

plt.figure(figsize=(10,8))
sns.heatmap(cosine_sim, annot = True, cmap='coolwarm')
plt.title('Cosine Similarity Heatmap')
plt.show()
